name: Build and Test with MySQL

on:
  workflow_dispatch:

jobs:
  build-test:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: dotnet.FakeStoreIngestor

    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: rootpass
          MYSQL_DATABASE: fakestore
          MYSQL_USER: appuser
          MYSQL_PASSWORD: apppass
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping -h localhost -uroot -prootpass"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

      # # Mock "FakeStore" upstream to avoid Cloudflare blocks in CI
      # fakestore-mock:
      #   image: clue/json-server:latest
      #   ports: [ "3000:80" ]
      #   # Mount our db.json into the container and tell json-server to use it
      #   options: >-
      #     --mount type=bind,source=${{ github.workspace }}/.github/mock/db.json,target=/data/db.json,readonly
      #     --health-cmd="wget -qO- http://localhost:80/products > /dev/null"
      #     --health-interval=5s --health-timeout=3s --health-retries=10

    steps:
      # Checkout code
      - name: Checkout repository
        uses: actions/checkout@v4

      # # Start mock json-server from db.json in your repo
      # - name: Start mock upstream (json-server)
      #   run: |
      #     docker run -d --name fakestore-mock \
      #       -p 3000:80 \
      #       -v "$GITHUB_WORKSPACE/.github/mock/db.json:/data/db.json:ro" \
      #       clue/json-server:latest \
      #       -H 0.0.0.0 -p 80 /data/db.json
      #     # wait for it
      #     for i in {1..30}; do
      #       if curl -sf http://localhost:3000/products > /dev/null; then
      #         echo "Mock is up!"
      #         break
      #       fi
      #       echo "Waiting for mock..."
      #       sleep 2
      #     done

      - name: Create mock db.json
        run: |
          mkdir -p .github/mock
          cat > .github/mock/db.json <<'JSON'
          {
            "products": [
              { "id": 1, "title": "Mock 1", "price": 10, "description": "d", "category": "c", "image": "i", "rating": { "rate": 4.2, "count": 10 } },
              { "id": 2, "title": "Mock 2", "price": 20, "description": "d", "category": "c", "image": "i", "rating": { "rate": 3.9, "count": 5 } },
              { "id": 3, "title": "Mock 3", "price": 30, "description": "d", "category": "c", "image": "i", "rating": { "rate": 4.8, "count": 7 } },
              { "id": 4, "title": "Mock 4", "price": 40, "description": "d", "category": "c", "image": "i", "rating": { "rate": 4.1, "count": 3 } },
              { "id": 5, "title": "Mock 5", "price": 50, "description": "d", "category": "c", "image": "i", "rating": { "rate": 3.5, "count": 12 } },
              { "id": 6, "title": "Mock 6", "price": 60, "description": "d", "category": "c", "image": "i", "rating": { "rate": 4.9, "count": 2 } }
            ]
          }
          JSON

      - name: Start mock upstream (json-server via npx)
        run: |
          npx --yes json-server --host 0.0.0.0 --port 3000 .github/mock/db.json &
          echo $! > mock.pid
          for i in {1..40}; do
            if curl -sf http://localhost:3000/products > /dev/null; then
              echo "Mock is up!"
              break
            fi
            echo "Waiting for mock..."
            sleep 1
          done

      - name: Smoke check mock upstream
        run: curl -sS http://localhost:3000/products | head -c 200

      # Setup .NET SDK (match your projectâ€™s version)
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      # Restore dependencies
      - name: Restore dependencies
        run: dotnet restore

      # Build
      - name: Build
        run: dotnet build --no-restore --configuration Release

      # Wait for MySQL to be ready
      - name: Wait for MySQL
        run: |
          for i in {1..30}; do
            if mysqladmin ping -h127.0.0.1 -P3306 -uappuser -papppass --silent; then
              echo "MySQL is up!"
              break
            fi
            echo "Waiting for MySQL..."
            sleep 2
          done

      # - name: Smoke check mock upstream
      #   run: curl -sS http://localhost:3000/products | head -c 200

      # # Run EF Core migrations (if you use them)
      # - name: Apply database migrations
      #   env:
      #     ConnectionStrings__Default: Server=127.0.0.1;Port=3306;Database=fakestore;User=appuser;Password=apppass;TreatTinyAsBoolean=false
      #   run: dotnet ef database update --project FakeStoreIngestor

      # # Run tests
      # - name: Test
      #   env:
      #     ConnectionStrings__Default: Server=127.0.0.1;Port=3306;Database=fakestore;User=appuser;Password=apppass;TreatTinyAsBoolean=false
      #   run: dotnet test --no-build --verbosity normal

      - name: Test
        env:
          ConnectionStrings__Default: Server=127.0.0.1;Port=3306;Database=fakestore;User=appuser;Password=apppass;TreatTinyAsBoolean=false;DefaultCommandTimeout=30
          Ingest__BaseUrl: http://localhost:3000/
          Ingest__ProductsEndpoint: products
        run: dotnet test --no-build --verbosity normal

      # # Start the API in background
      # - name: Run API in background
      #   run: |
      #     dotnet run --project FakeStoreIngestor --urls "http://localhost:5171" &
      #     echo $! > api.pid
      #     # wait for it to start
      #     for i in {1..20}; do
      #       if curl -s http://localhost:5171/health > /dev/null; then
      #         echo "API is up!"
      #         break
      #       fi
      #       echo "Waiting for API..."
      #       sleep 2
      #     done

      # # Start the API in background on a fixed port
      # - name: Run API in background
      #   env:
      #     ASPNETCORE_URLS: http://localhost:5171
      #   run: |
      #     dotnet run --configuration Release &
      #     echo $! > api.pid
      #     # Wait for API to be healthy
      #     for i in {1..30}; do
      #       if curl -s http://localhost:5171/health > /dev/null; then
      #         echo "API is up!"
      #         break
      #       fi
      #       echo "Waiting for API..."
      #       sleep 2
      #     done

      # Start API on a fixed port and point it to services via env vars
      - name: Run API in background
        env:
          ASPNETCORE_URLS: http://localhost:5171
          # MySQL connection string
          ConnectionStrings__Default: Server=127.0.0.1;Port=3306;Database=fakestore;User=appuser;Password=apppass;TreatTinyAsBoolean=false;DefaultCommandTimeout=30
          # IMPORTANT: override upstream only in CI (mock server)
          Ingest__BaseUrl: http://localhost:3000/
          Ingest__ProductsEndpoint: products
        run: |
          dotnet run --configuration Release &
          echo $! > api.pid
          # Wait for API health
          for i in {1..30}; do
            if curl -sf http://localhost:5171/health > /dev/null; then
              echo "API is up!"
              break
            fi
            echo "Waiting for API..."
            sleep 2
          done

      # - name: Check upstream fakestore reachability
      #   run: |
      #     set -e
      #     curl -v -I https://fakestoreapi.com/products || true

      # Import first 5 products
      - name: Import first 5
        run: |
          curl -v -X POST 'http://localhost:5171/import/5' -H 'accept: */*'

      - name: Read one
        run: |
          curl -v -X GET 'http://localhost:5171/products/1' -H 'accept: */*'


      - name: List all
        run: |
          curl -v -X GET 'http://localhost:5171/products' -H 'accept: */*'

      # Kill API after seeding
      - name: Stop API
        if: always()
        run: |
          kill $(cat api.pid) || true
          kill $(cat mock.pid) || true

      # - name: Stop mock
      #   if: always()
      #   run: docker rm -f fakestore-mock || true
